<?xml version="1.0"?>
<document>

    <properties>
        <author email="tirsen@users.sourceforge.net">Jon Tirsen</author>
        <title>Nanning Aspects</title>
    </properties>

    <body>

        <section name="Summary">
            <p>
                Nanning is a simple yet scaleable aspect-oriented framework based on the ideas of
                implementing AOP in Java outlined by Rickard Oberg in his
                <a href="http://dreambean.com">blog</a>.
            </p>
            <p>
                Nanning is also nice "little" town in Guanxi province in southern China. It's about 1-2
                million inhabitants which barely makes it a town by chinese standards. It is not to be
                confused with the much larger Nanking/Nanjing.
            </p>

            <subsection name="Features">
                <p>
                    Nanning Aspects has the following features:
                </p>
                <ul>
                    <li>
                        An aspect consists of an interface, a target-object and a set of interceptors
                        (advises on method-calls), these interceptors intercept calls on the interface on
                        it's way to the target.
                    </li>
                    <li>
                        An aspect-class consists of a set of aspects and can in it's own right have an
                        interface, target and interceptors. The interceptors of the class will always be
                        executed before <em>all</em> other interceptors, even the interceptors of the other
                        aspects of the class.
                    </li>
                    <li>
                        When instantiated all these aspects are put together using a Proxy in the
                        Reflection API.
                    </li>
                    <li>
                        Attributes (Javadoc-like tags) can also be added to classes, fields and methods.
                        These attributes are accesible at runtime.
                    </li>
                    <li>
                        Super-simple implementation. Really! Anybody can do it! Even me!
                    </li>
                </ul>
            </subsection>

            <subsection name="Restrictions">
                <ul>
                    <li>
                        You can only advise on method-call pointcuts which is far from the power that
                        for example <a href="http://www.aspectj.org">AspectJ</a> offers. On the other hand
                        compared to the complexity of AspectJ Nanning is much, much simpler. In reality
                        many of the benefits of AOP can be reached with this simple construct.
                    </li>
                    <li>
                        All your objects need to have interface and implementation separated, that is all
                        public methods (accessible to clients) needs to be placed in an interface which is
                        implemented by the actual class. In contrast to EJB your implementation must
                        "implement" the interface, which also forces your implementation to actually
                        implement all methods.
                    </li>
                </ul>
            </subsection>

            <subsection name="Non-features">
                <p>
                    Nanning Aspects do not have these features (yet?):
                </p>
                <ul>
                    <li>
                        Almost no support for inheritance at all. For example you can't even call methods
                        that are inherited in your interfaces.
                    </li>
                    <li>
                        Method-selectors that selects what methods an interceptor should intercept.
                    </li>
                    <li>
                        A mega-cool logo.
                    </li>
                    <li>
                        A set of interceptors that will supersede EJB forever!
                    </li>
                </ul>
            </subsection>

            <subsection name="Using aspects">
                <p>
                    This is an example from the unit-tests:
                </p>
                <source><![CDATA[
AspectClass aspectClass = new AspectClass();
aspectClass.setInterface(Intf.class);
aspectClass.addInterceptor(MockInterceptor.class);
aspectClass.addInterceptor(NullInterceptor.class);
aspectClass.setTarget(Impl.class);
AspectDefinition aspectDefinition = new AspectDefinition();
interfaceDefinition.setInterface(SideAspect.class);
interfaceDefinition.addInterceptor(NullInterceptor.class);
interfaceDefinition.addInterceptor(MockInterceptor.class);
interfaceDefinition.setTarget(SideAspectImpl.class);
aspectClass.addSideAspect(interfaceDefinition);

Object bigMomma = aspectClass.newInstance();
                ]]></source>
                <p>
                    Nanning also has an XML-configuration format if that's what you prefer.
                </p>
            </subsection>

            <subsection name="Using runtime attributes">
                <p>
                    This is an example from the unit-tests:
                </p>
                <p>
                    The class (with the attributes):
                </p>
                <source><![CDATA[
/**
 * @classAttribute classValue
 */
public class AttributesTestClass
{
    /**
     * @fieldAttribute fieldValue
     */
    public String field;

    /**
     * @methodAttribute methodValue
     */
    public void method()
    {
    }

    /**
     * @methodAttribute argMethodValue
     */
    public void method(String arg)
    {
    }
}
                ]]></source>
                <p>
                    The code that compiles and accesses these attributes:
                </p>
                <source><![CDATA[
AttributesCompiler attributesCompiler = new AttributesCompiler();
attributesCompiler.setSrc(new File("src" + File.separator + "test"));
attributesCompiler.setDest(targetDir);
attributesCompiler.execute();

assertEquals("classValue", Attributes.getAttribute(AttributesTestClass.class, "classAttribute"));
Field field = AttributesTestClass.class.getDeclaredField("field");
assertEquals("fieldValue", Attributes.getAttribute(field, "fieldAttribute"));
Method method = AttributesTestClass.class.getMethod("method", null);
assertEquals("methodValue", Attributes.getAttribute(method, "methodAttribute"));
Method argMethod = AttributesTestClass.class.getMethod("method", new Class[]{String.class});
assertEquals("argMethodValue", Attributes.getAttribute(argMethod, "methodAttribute"));
                ]]></source>
                <p>
                    The attributes-compiler can also be used as an ant-task (or better yet! inside
                    <a
                        href="http://jakarta.apache.org/maven">maven</a>). This is left as an exercise
                    for the interested reader (yeah, yeah, I'm lazy...).
                </p>
            </subsection>

            <subsection name="Configuration file format">
                <p>
                    If you prefer XML over Java you can create a configuration file with the following
                    format:
                </p>
                <source><![CDATA[
<aspect-repository>
    <aspect>
        <interface>
            com.tirsen.nanning.test.SideAspect
        </interface>
        <interceptor>
            com.tirsen.nanning.test.NullInterceptor
        </interceptor>
        <interceptor>
            com.tirsen.nanning.test.MockInterceptor
        </interceptor>
        <target>
            com.tirsen.nanning.test.SideAspectImpl
        </target>
    </aspect>
    <class>
        <interface>
            com.tirsen.nanning.test.Intf
        </interface>
        <interceptor>
            com.tirsen.nanning.test.MockInterceptor
        </interceptor>
        <interceptor>
            com.tirsen.nanning.test.NullInterceptor
        </interceptor>
        <target>
            com.tirsen.nanning.test.Impl
        </target>

        <aspect interface="com.tirsen.nanning.test.SideAspect" />
    </class>
</aspect-repository>
                ]]></source>
                <p>
                    Access the configuration with code along the following lines:
                </p>
                <source><![CDATA[
AspectRepository aspectRepository = new AspectRepository();
aspectRepository.configure(AspectRepositoryTest.class.getResource("aspect-repository-test.xml"));
Object bigMomma = aspectRepository.newInstance(Intf.class);
                ]]></source>
                <p>
                    Or if you want to cheat you can name the file "aspect-repository.xml" and put it
                    in your classpath. In that case your code would look more like:
                </p>
                <source><![CDATA[
Object bigMomma = AspectRepository.getInstance().newInstance(Intf.class);
                ]]></source>
                <p>
                    Oh, forgot to mention... The configuration file is actually a
                    <a href="http://jakarta.apache.org/commons/sandbox/jelly">Jelly</a>-script, which means
                    you can probably do all sorts of crazy things and probably also embed Nanning-aspects
                    inside other Jelly-scripts. I haven't had time to test all the implications of this
                    feature but I guess it's kind of cool. I guess this also breaks the "simplest thing that
                    could possibly work"-design I usually prefer but codewise it was just slightly more
                    or just as complex as parsing the XML by hand, mostly due to Jelly being designed so
                    well.
                </p>
            </subsection>

            <subsection name="Stateless interceptors">
                <p>
                    If you're interceptor does not keep state implement the marker-interface
                    <a href="apidocs/com/tirsen/nanning/StatelessInterceptor.html">StatelessInterceptor</a>.
                    If you do Nanning will only instantiate one instance and use that as the interceptor
                    for the whole system. Example:
                </p>
                <source><![CDATA[
public class NullInterceptor implements Interceptor, StatelessInterceptor
{
    public Object invoke(Invocation invocation) throws Throwable
    {
        return invocation.invokeNext();
    }
}
                ]]></source>
            </subsection>

            <subsection name="On method-selectors">
                <p>
                    Method-selectors are regex-patterns that are used to select what method an interceptor
                    will be applied to. I haven't yet found a use for method-selectors and therefor they are
                    not yet implemented it in Nanning.
                </p>
                <p>
                    This is how I do it. My TransactionInterceptor will check an attribute of the method
                    that specifies wheather it requires transactions or not. Using method-selectors that
                    say "always have transactions for methods starting with 'set' or 'update', ie.
                    'set* | update*'" is error-prone because you may have other methods like "moveTo",
                    "checkout" or "create" that do not follow this convention but still requires
                    transactions, or the other way around which is as bad because it will result in a
                    serious performance-hit. This forces you to do one of two
                    things: always follow your specified method-naming-pattern or have a very complex
                    method-selector. Neither of these work-arounds are satisfactory. That's why I use
                    runtime-attributes instead of method-naming-conventions together with method-selectors.
                </p>
                <p>
                    There could sometimes also be a performance-gain in not executing unneeded interceptors.
                    This performance-gain can not be accomplished by using attributes. But there is some
                    problems with this too that can affect performance. Because how do you implement method-
                    selectors? Either one needs to check the selector at runtime which will be too slow.
                    The other way is to cache the result of these checks when defining the aspect-class.
                    This is also problematic because it could result in increased footprint.
                    There may be other ways, but I don't see them.
                </p>
            </subsection>
        </section>

    </body>
</document>
